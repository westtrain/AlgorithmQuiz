import sys

# 소수 판별 함수
def is_prime(num):
    if num <= 1:  # 1 이하의 수는 소수가 아님
        return False
    if num <= 3:  # 2와 3은 소수
        return True
    if num % 2 == 0 or num % 3 == 0:  # 2나 3으로 나누어 떨어지면 소수가 아님
        return False
    i = 5
    while i * i <= num:  # 제곱근까지만 확인
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

# 입력 받기
input = sys.stdin.read
data = input().split()
N = int(data[0])  # 숫자의 개수
numbers = list(map(int, data[1:N+1]))  # 주어진 숫자들

# 소수의 개수 세기
prime_count = 0
for number in numbers:
    if is_prime(number):
        prime_count += 1

# 결과 출력
print(prime_count)

'''
왜 i를 5부터 시작하고, 6씩 더할까?
우선, 2와 3으로 나눌 수 있는지 먼저 확인했어요. 왜냐하면 많은 수들이 2나 3으로 나눠지기 때문이에요. 그래서 2나 3으로 나눠지면 바로 "이 숫자는 소수가 아니야!"라고 말할 수 있어요.
2와 3으로 나눠지지 않는다면, 이제 5부터 시작해서 좀 더 큰 수들로 나눠봐야 해요. 여기서 재미있는 건, 숫자를 6씩 더하면서 확인하는 건데, 이는 2와 3의 배수를 피하기 위해서예요. 이미 2와 3으로 나눠지지 않는다는 걸 알고 있으니까요!

while i * i <= num: 이건 뭐죠?
이 부분은 "i의 제곱이 num보다 작거나 같을 때까지"라는 뜻이에요. 왜냐하면 소수를 판별할 때, 그 숫자의 "제곱근"까지만 확인해도 충분하기 때문이에요. 그 이상의 수로 나눠봐도 이미 결과는 나와 있거든요!

if num % i == 0 or num % (i + 2) == 0:
여기서는 num이 i로 나눠지거나 (즉, 나머지가 0이거나), i+2로 나눠지는지 확인해요. 나머지가 0이라는 건 그 숫자로 딱 나눠진다는 뜻이죠. 만약 딱 나눠진다면, 그 숫자는 소수가 아니에요.
i와 i+2 두 개의 숫자로 나누는 이유는, 빠르게 여러 숫자를 확인하기 위해서예요. 그렇게 하면 더 많은 수를 빨리 건너뛸 수 있으니까요.

i += 6
마지막으로 i에 6을 더해요. 이건 다음으로 확인할 숫자로 넘어가는 거예요. 이렇게 6씩 더하는 이유는 위에서 말했듯이, 2나 3의 배수를 피해서 더 효율적으로 소수를 찾기 위해서예요.
'''
